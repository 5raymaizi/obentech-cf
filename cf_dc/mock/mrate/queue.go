// Code generated by MockGen. DO NOT EDIT.
// Source: logic/rate/queue.go

// Package mrate is a generated GoMock package.
package mrate

import (
	exchange "cf_arbitrage/exchange"
	rate "cf_arbitrage/logic/rate"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockQueue is a mock of Queue interface.
type MockQueue struct {
	ctrl     *gomock.Controller
	recorder *MockQueueMockRecorder
}

// MockQueueMockRecorder is the mock recorder for MockQueue.
type MockQueueMockRecorder struct {
	mock *MockQueue
}

// NewMockQueue creates a new mock instance.
func NewMockQueue(ctrl *gomock.Controller) *MockQueue {
	mock := &MockQueue{ctrl: ctrl}
	mock.recorder = &MockQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueue) EXPECT() *MockQueueMockRecorder {
	return m.recorder
}

// CanClose mocks base method.
func (m *MockQueue) CanClose() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanClose")
	ret0, _ := ret[0].(bool)
	return ret0
}

// CanClose indicates an expected call of CanClose.
func (mr *MockQueueMockRecorder) CanClose() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanClose", reflect.TypeOf((*MockQueue)(nil).CanClose))
}

// CanOpen mocks base method.
func (m *MockQueue) CanOpen() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanOpen")
	ret0, _ := ret[0].(bool)
	return ret0
}

// CanOpen indicates an expected call of CanOpen.
func (mr *MockQueueMockRecorder) CanOpen() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanOpen", reflect.TypeOf((*MockQueue)(nil).CanOpen))
}

// PushSpot mocks base method.
func (m *MockQueue) PushSpot(book *exchange.Depth) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PushSpot", book)
}

// PushSpot indicates an expected call of PushSpot.
func (mr *MockQueueMockRecorder) PushSpot(book interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushSpot", reflect.TypeOf((*MockQueue)(nil).PushSpot), book)
}

// PushSwap mocks base method.
func (m *MockQueue) PushSwap(book *exchange.Depth) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PushSwap", book)
}

// PushSwap indicates an expected call of PushSwap.
func (mr *MockQueueMockRecorder) PushSwap(book interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushSwap", reflect.TypeOf((*MockQueue)(nil).PushSwap), book)
}

// Reset mocks base method.
func (m *MockQueue) Reset(cfg rate.QueueConfig) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reset", cfg)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Reset indicates an expected call of Reset.
func (mr *MockQueueMockRecorder) Reset(cfg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockQueue)(nil).Reset), cfg)
}
